## Composing Effects with Monad Transformers

Monadic effect composition is one of the more difficult topics in the functional paradigm. It needs some experience two apply the technique properly. In this course we will delve deeply into the topic. Hand in there!

### Monads do not compose in general

As opposed to functors and applicatives monads of different type do not compose in general, that is, there is no general, mechanical way to compose any two monads so that the result is always a new, combined one. We cannot just write:

```
// mmx has type M<N<A>> where M and N are monads

chain1(mmx) (mx => // M layer
  chain2(mx) (x => // N layer
    ...));
```
Some compositions will not work at all. Others will break the monad laws and behave unexpectedly.

The problem has to do with the way the different effect layers `M` and `N` are interleaved. We can reproduce it by applying monadic actions to functors, where `M` is of type array and `N` of type `Option`:

```javascript
// unoin constructor

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

// OPTION

const Option = union("Option");

const None = Option("None", {});

const Some = some => Option(Some, {some});

// functor

const optMap = f => tx =>
  match(tx, {
    None: _ => None,
    Some: ({some: x}) => Some(f(x))
  });

// ARRAY

// functor

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

// MAIN

const foo = s => [Some(s.toUpperCase())]; // monadic action

const ttx = [Some("foo")];

arrMap(optMap(foo)) (ttx); // [Some<[Some<string>]>]
```
[run code](https://repl.it/@scriptum/NavyNovelScale)

Without joining the effects `M<N<M<N<A>>>>` are interleaved. Now it is impossible to join any `M` and any `N` in a general manner. The only thing we could do would be a transformation to `M<M<N<N<A>>>>` but that would require cummutativity for the involved monads.

### Higher order monads to the rescue

If there is no general solution to this problem, maybe we can find a less general, more ad-hoc one. We could simply write all our monad compositions by hand, of course, but that would clearly violate the DRY principle. But maybe we are able to implement a specialized version of each monad that takes another monad of any type and always returns a law-abiding, new combined monad. These class of monads would probably have two other important characteristics:

* there is no one-to-one relationship between a specialiced monad and its regular counterpart
* there might not be a specialized monad for every regular monad

Such a class of specialiced monads does exist. They are called monad transformers. A monad transformer is itself a monad that takes another monad as its argument and returns a law-abiding, new combined monad. We have seen this construct before: Transformers are higher order monads.

Transformers are also ad-hoc and thus a bit hackish and awkward to use. These are the reasons why effect composition is still under active research and a couple of alternative approaches have emerged. I will cover these approaches in later chapters of this course.

### Transformers under the hood

A higher order monad `T` that represents one possible implementation of a transformer for the underlying monadic type `M` constitutes itself at the type level through a specific implementation of `chain` and `of`, where both operations take the corresponding operations of another monad `N` of different type:

```javascript
const ofT = ofN => ...
const chainT = chainN => ...
```
It is important to understand that the transformer `T` must comply with the following two rules:

* `T` must not use or reference `M`'s `chain`/`of` operations in any way
* `T` must not know anything about `N` except that it is also a monad

This is likely to become clearer if we replace the type variables with actual types. Say, if `M` is an array, then `T` implements the array monad transformer. `T` must not know anything about both `M` and `N` except that `M` is of type array and `N` is another type and both implement the monad type class. Both rules make sense, because in spite of the name a monad transformer is a new, completely independent monad and it should work with any monad that is passed to it.

The monad `N`, which is passed to the transformer as an argument, is called the base monad. It constitutes the outer monad of the combined type, whereas the transformer constitutes the inner monad: `M<T<A>>`. However, this only holds for the term and type level, not so much for the effect level.

From the perspective of the combined effects there is no clear separation but effects are interleaved in a more or less complex fashion. The only general observation you can make is that the effect of the inner monad and thus the monad transformer is the dominant one. It transforms the effect of the outer one.

### Monad transformer stacks

The monad transformer mechanism is composable, i.e. you can take a partially applied monad transformer and apply it to another one. In functional programming jargon this forms a monad transformer stack.

* the innermost monad determines the dominant semantics of the stack

Please note that the transformer stack we are going to build in the following sections is rather contrived. I want you to solely focus on the mechanics of the effect composition rather than on the question if a particularly transformer stack is useful in practice.

#### `EffT`/`Array`

We start with a computation with two effects,

* a deferring
* and non-deterministic one

We use the `EffT` monad transformer that takes the `Array` monad to encode the monadic composition:

```javascript
// record constructor

const record = (type, o) =>
  (o[type.name || type] = type.name || type, o);

// common combinators

const comp = f => g => x => f(g(x));

// EFFECT

const Eff = eff =>
  record(Eff, {get eff() {return eff()}});

// Monad

const effOf = x => Eff(() => x);

const effChain = mx => fm =>
  Eff(() => fm(mx.eff).eff);

// Monad Transformer

const effOfT = of => x => of(Eff(() => x));

const effChainT = ({map, chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    Eff(() => map(my => my.eff) (fmm(mx.eff))));

const effLiftT = of => fm =>
  comp(of) (fm);

// ARRAY

// Functor

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

// Monad

const arrChain = mx => fm =>
  arrFold(acc => x =>
    arrAppend(acc) (fm(x))) ([]) (mx);

const arrOf = x => [x];

// auxiliary functions

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  xs.concat(ys);

// ARREFF

// Monad

const arrEffChain = effChainT(
  {map: arrMap, chain: arrChain, of: arrOf});

const arrEffOf = effOfT(arrOf);

// auxiliary functions

const arrEffFilter = p => arrEffChain(mmx) (x =>
  p(x)
    ? [effOf(x)]
    : []);

const arrEffTake = n => xs =>
  Eff(() => {
    const go = i => acc => {
      if (acc.length === n || xs.length === i)
        return acc;

      else {
        const ys = xs[i].eff;

        return ys.length === 0
          ? go(i + 1) (acc)
          : go(i + 1) (acc.concat(ys));
      }
    };

    return go(0) ([]);
  });

// MAIN

const randomNum = Eff(
  () => {
    const n = Math.round(Math.random() * 100)
    console.log(n); // A
    return n});

const mmx = [randomNum, randomNum, randomNum, randomNum, randomNum];

const main = arrEffTake(3)
  (arrEffFilter(x => (x & 1) === 0));

// no effects yet...

main.eff; // logs pseudo random numbers x-times and yields up to three even ones
```
[run code](https://repl.it/@scriptum/DelayedMeekCache)

The deferring `Eff` effect is used to separate impure synchronous computations from the pure realm of your program. The trick is that `Eff` computations are wrapped in a thunk and thus only describe computations, which will only be evaluated at a later time. Since `Eff` forms a monad we can compose descriptions of computations and pretend they are purely functional.

Now that we better understand `Eff`'s semantics we can comprehend what is happening in the example above. First we construct the `ArrEff` monad by passing `arrChain` and `arrOf` to the `EffT` monad transformer functions. Then we fill an array with five descriptions of how to generate a pseudo random number. Next we filter the even pseudo random numbers and take up to three of them or more precisely, we write descriptions how to filter and take up to three descriptions of how to generate pseudo random numbers. At this point the non-deterministic effect kicks in, because we do not know upfront how many even numbers we will collect.

Line `A` proves that no effect is performed unless we access `main.eff`. `Eff` abstracts from the thunk interface through an object getter, hence we can drop the parenthesis in `main.eff()`. As soon as we unleash the effects the computation runs until three even pseudo random numbers are generated. If it gathers three even numbers before all five descriptions are evaluated, the computation is short circuited and the result array is returned, i.e. only the necessary operations are actually performed. It is a characteristics of lazy algorithms that the consumer of a data structure determines what part of the structure is interesting, whereas the producer only declares it. `Eff` is an thrilling type, because it actually comprises two different types:

* in the pure realm of the example it has type `[Eff]`
* in the impure realm it has type `[number]`

Simply put we can say that the former type corresponds to the compile/interpretation time of our program, whereas the latter correspond to its runtime. While writing code everything is a pure description of an impure program, but as soon as we run it impurity takes over.

#### `OptionT`/`EffT`/`List`

Let us add the effect of computations that may have no result.

```javascript
TODO
```
[run code]()

#### `OptionT`/`EffT`/`ListT`/`Trampoline`

* adds stack-safety to your monad transformer stack
* `Trampoline` does not have a transformer

### Illegal monad transformers

#### `ArrayT`/`Option` done wrong

#### `ArrayT`/`Option` done right

### Effects are not commutative

* transformers are not commutative
* the order of a stack determines its semantics
* the interaction of two effects can be controlled by picking a specific stack order
* Either(List):  Each branch can fail separately
* List(Either): The whole non-deterministic computation can fail with a single error

### Explicit versus implicit lifting

* polymorphic `lift` function

### Where are the type wrappers?

### Alternative approaches

* effect composition is under active reasearch

#### Pre-composed monads

* you can write your own hard-coded monad composition

#### Continuation monad encodings

#### Outlook on more advanced alternatives

***

* [run code](https://repl.it/@scriptum/FelineLoyalCache) `OptionT`/`Eff`
* [run code](https://repl.it/@scriptum/ClumsyDullApplicationframework) `OptionT`/`EffT`/`Array`
* [run code](https://repl.it/@scriptum/WarpedBeigeNumerators) `OptionT`/`Array`
* [run code](https://repl.it/@scriptum/FrizzyWornFormulas) `OptionT`/`Trampoline`
* [run code](https://repl.it/@scriptum/JumboTrickyActivecontent) `ArrayT`/`Option`
* [run code](https://repl.it/@scriptum/OrganicWheatMisrac) `ArrayT`/`Option`
* [run code](https://repl.it/@scriptum/NutritiousRowdyWearables) `ArrayT`/`Option` validation
* [run code](https://repl.it/@scriptum/MoralAuthorizedComputergames) `ArrayT`/`Option` done right

* Kleisli arrows are monad transformers where an arbitrary outer monad is composed with the function monad
* add Either to a ArrayT monad transformer to get short circuit semantics
* there is no one-to-one relationship between monad and transformer
* there is not really an inner and an outer monad but the effects are rather interleaved
* transformers are point-free style
