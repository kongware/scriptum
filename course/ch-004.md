## Lawful and lawless abstractions

There is one mean to abstract them all in functional programming: functions, also known as lambdas.

### Rationale for abstractions

Lambda abstractions are useful for various reasons. Here is an incomplete list:

* code reuse

As functional programmers we always strive to find small, reusable functions to keep our code DRY. Instead of `lenAll`, for instance,

```javascript
const lenAll = xs =>
  xs.map(s => s.length);
  
lenAll(["f", "fo", "foo"]);
```

we reuse library functions:

```javascript
const map = f => xs =>
  xs.map(f);
  
const len = xs => xs.length;

map(len) (["f", "fo", "foo"]);
```
* reduce boilerplate

Every time we recognize recurring code patterns we try to abstract them as a function.

* handle state

Every function has arguments and a return value where we can store our program state. So instead of (re-)assigning a new value to a variable we call a function that creates its own scope and pass the new value as an argument. As soon as the function is finished it creates another state and returns it.

* replace statements with expressions

Expressions are first class citizens, hence we want them everywhere throughout our code:

```javascript
const app_ = x => f => f(x);

app_({tag: â€œfooâ€}) (({tag}) => {
  switch(tag) {
    case â€œfooâ€:
       return ...;

    case â€œbarâ€:
       return ...;

    default:
       return ...;
  }
});
```
Function as wrappers allow us to turn statements into first class expressions without losing the concise and familiar syntax.

* avoid explicit lambdas

Take a look at `compAll`:

```javascript
const compAll = fs => x =>
  fs.reduce((y, f) => f(y), x);
```
It abstracts from arbitrarily long function compositions. However, it feels like we stopped midway through the process:

```javascript
const compAll = fs
  reduce(comp) (id);

// library code

const id = x => x;

const comp = f => g => x =>
  f(g(x));

const reduce = f => acc => xs =>
  xs.reduce((acc, x) => f(acc) (x));
```
We successfully abstracted from a lambda - a higher-order abstraction so to speak. The resulting code is not only more succinct but also more declarative and easer to reason about, because we replaced an explicit lambda that produces a decent amount of syntactic noise with plain names.

* utilize partial application

Can we convert an operation like `x * y` into a more lazy and thus more flexible one?

```javascript
const map = f => xs =>
  xs.map(x => f(x));
  
const mul = x => y => x * y;

map(mul(10));
```
### Lawful abstractions

What makes an abstraction lawful? If it adheres to one or more algebraic laws like

* Absorption
* Associativity
* Commutativity
* Distributivity
* Homomorphism
* Idempotence
* Identity
* Inverse
* Transitivity
* etc.

You do not need to know what these laws mean in detail at this point, but you should make yourself acquainted with them eventually. Not every lambda abstraction follows laws, especially not normal functions. However, laws are often assigned to type class functions. We will learn about type classes in a later chapter of this course.

### Unprincipled or even lawless abstractions

What does an unprincipled or even lawless lambda abstraction look like, which we should try to avoid?

* it has no type (applies only to untyped settings, of course)
* it resembles an algebraic structure but violates its laws
* it is used against its intention
* it follows no laws at all
* it is not widely used

Please note that the last three points are merely soft facts, that is to say for instance, not every uncommon or unknown abstraction is an unprincipled one. However, the chance that it is an unprincipled one is much higher, because the odds that you have found a new useful, reusable abstraction that no one found before are rather small.

I will not show any examples, because such an endeavor would not be particularly helpful. This is just the attempt to sensitize you on the subject. The ability to recognize unprincipled or lawless abstractions is an ongoing process and separates advanced functional programmers from novices.

### The tradeoff of abstractions

The process of abstraction in programming is evolutionary and mainly depends on the skill level of the involved programmers. We can often add another level of abstraction to our code. While abstracting in general raises code quality, it also makes it harder for outsiders to comprehend your intentions. You should therefore always take another objective into account:

**Keep your code accessible**

This is a highly opinion-based statement, of course and, as I said before, mainly depends on the skill level of the team. The more skilled a team is the more abstractions it can conceive.

### Examples of reasonable abstractions

The first example demonstrates composition in the second argument of a curried function:

```javascript
const comp2nd = f => g => x => y =>
  f(x) (g(y));

const fold = f => init => xs =>
  xs.reduce((acc, x) => f(acc) (x), init);

const comp = f => g => x =>
  f(g(x));

const id = x => x;
const empty = [];

const foldMap = ({fold, append, empty}) => f =>
  fold(comp2nd(append) (f)) (empty);

foldComp = foldMap({fold, append: comp, empty: id});

foldComp(add) ([1, 2, 3]) (100); // 106
```
[run code](https://repl.it/@scriptum/CapitalRosyEntropy)

The second example shows composition in both arguments of a curried function:

```javascript
const compOn = f => g => x => y => f(g(x)) (g(y));

const sortBy = f => xs =>
  [...xs].sort((x, y) => f(x) (y));

const compare = x => y =>
  x < y ? -1
    : x > y ? 1
    : 0;

const fst = ([x, y]) => x;

sortBy(compOn(compare) (fst))
  ([[2, "world"], [4, "!"], [1, "hello"]]); // [[1, "hello"], [2, "world"], [4, "!"]]
```
[run code](https://repl.it/@scriptum/ThankfulMoralFiles)

### The harm of over-engineering

While it is a good intention to reduce the need of boolean based conditionals in your code, you should not try to encode conditional statements as functions:

```javascript
const ifElse = p => f => g => x => {
  if (p(x))
    return f(x);
   
  else
    return g(x);
}

ifElse(isEven) (doThis) (doThat) (2);
```
The example above may work with regard to the simple scenario. There are a million other slightly different ways to express conditional branching, especially if things get more complex. Abstracting from conditions this way quickly leads to a mess:

**Do never try to encode `if`/`else` or `switch` statements with specialized functions!**

However, in Javascript it makes a lot of sense to use function wrappers in order to turn conditional statements into first class expressions:

```javascript
const app_ = x => f => f(x);

const ifElse = app_; // function alias

ifElse(obj) (({foo, bar}) => {
  if (foo)
    return ...
    
  else if (bar)
    return ...
    
  else
    return ...
});
```
The former example of this section demonstrates the harm of over-engineering. There are numerous other ones. Recognizing the overuse of abstractions again separates the seasoned functional programmer from the novice. You will get there eventually, provided you keep on learning.

### Editor's note

If you enjoyed this chapter please ðŸŒŸ scriptum here on Github or share it on your preferred social media platform. If you found a mistake or inaccuracy or want to propose an improvement please file an issue/feature. Thank you.

[&lt; prev chapter](https://github.com/kongware/scriptum/blob/master/course/ch-003.md) | [TOC](https://github.com/kongware/scriptum#functional-programming-course-toc) | [next chapter &gt;](https://github.com/kongware/scriptum/blob/master/course/ch-005.md)
