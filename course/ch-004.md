## Lawful and lawless abstractions

**[Editor's note: this chapter is under edit]**

There is one mean to abstract them all in functional programming: functions, also known as lambdas.

### Rationale for abstractions

Lambda abstractions are useful for various reasons. Here is an incomplete list:

* code reuse

As functional programmers we always strive to find small, reusable functions to keep our code DRY. Instead of `lenAll`

```javascript
const lenAll = xs =>
  xs.map(s => s.length);
  
lenAll(["f", "fo", "foo"]);
```

we reuse common functions:

```javascript
const map = f => xs =>
  xs.map(f);
  
const len = xs => xs.length;

map(len) (["f", "fo", "foo"]);
```
* reduce boilerplate

Any time we recognize recurring code patterns we try to abstract them in the form of a function.

* handle state

Every function has arguments and a return value where we can store our program state. So instead of (re-)assigning a new value to a variable we call a function that creates its own scope and pass the new value as an argument. As soon as the function is finished it creates another new value and returns it.

* replace statements with expressions

Expressions are first class citizens, hence we want them everywhere throughout our code:

```javascript
const app_ = x => f => f(x);

app_({tag: â€œfooâ€}) (({tag}) => {
  switch(tag) {
    case â€œfooâ€:
       return ...;

    case â€œbarâ€:
       return ...;

    default:
       return ...;
  }
});
```
Function as wrappers allow us to turn statements into first class expressions without losing the concise and familiar syntax.

* avoid explicit lambdas

Take a look at `compAll`:

```javascript
const compAll = fs => x =>
  fs.reduce((y, f) => f(y), x);
```
It abstracts from abritrarily long function compositions. However, it feels like we stopped in the middle of the process:

```javascript
const compAll = fs
  reduce(comp) (id);

// library code

const id = x => x;

const comp = f => g => x =>
  f(g(x));

const reduce = f => acc => xs =>
  xs.reduce((acc, x) => f(acc) (x));
```
We successfully abstracted from a lambda - a higher-order abstraction so to speak. The resulting code is not only more succinct but also more declarative and easer to reason about, because we replaced an explicit lambda that produces a decent amount of syntactic noise with comprehensive names.

* utilize partial application

Can we convert an operation like `x * y` into a more lazy and thus more flexible one?

```javascript
const map = f => xs =>
  xs.map(x => f(x));
  
const mul = x => y => x * y;

map(mul(10));
```
### Lawful abstractions

What makes an abstraction lawful? If it adheres to one or more algebraic laws like

* associativity
* commutativity
* distributivity
* identity
* inverse
* homomorphism
* idempotence
* closure
* etc.

First of all you do not need to know what these laws mean in detail at this point, but you should make yourself acquainted with them eventually. Not every lambda abstraction follows laws, especially not normal functions. However, laws are often assigned to type class functions. We will learn about type classes in a later chapter of this course.

### Unprincipled or even lawless abstractions

What does a lambda abstraction look like that we should try to avoid because it is unprincipled or even lawless?

* it has no type (applies only to untyped settings, of course)
* it resembles an algebraic structure but breaks its laws
* it follows no laws at all
* it is not widely used

### The tradeoff of abstractions

The process of abstracion in programming is evolutionary and mainly depends on the skill level of the involved programmers. We can often add another level of abstraction to our code. While abstracting raises the quality of code in general, it also makes it harder for outsiders to comprehend your intentions. You should therefore always take another objective into account:

**Keep your code accessable**

This is a highly opinion-based statement, of course and, as I said before, mainly depends on the skill level of the team. The more skilled a team is the more abstractions it can conceive.

### The harm of over-engineering

* conditions as function encoding

***

#### Quaternary combinators with two function arguments

`comp2nd = f => g => x => y => f(x) (g(y))`

If we deal with binary functions it is sometimes convenient to defer a composition until we provide the second argument. In the example `comp2nd` is used to construct the famous `foldMap` combinator. It is a rather complex ad-hoc polymorphic combinator, so do not worry too much about the details:

```javascript
const comp2nd = f => g => x => y =>
  f(x) (g(y));

const fold = f => init => xs =>
  xs.reduce((acc, x) => f(acc) (x), init);

const comp = f => g => x =>
  f(g(x));

const id = x => x;
const empty = [];

const foldMap = ({fold, append, empty}) => f =>
  fold(comp2nd(append) (f)) (empty);

foldComp = foldMap({fold, append: comp, empty: id});

foldComp(add) ([1, 2, 3]) (100); // 106
```
[run code](https://repl.it/@scriptum/CapitalRosyEntropy)

The reason why we need to compose in the second argument of `append` is that `foldMap` does not depend on a right associative fold but on a left associative one. As you may know both folds differ in the order the accumulator `acc` and the current element `x` is provided to the algebra `f`.

`compBin = f => g => x => y => f(g(x) (y))`

With `compBin` both function arguments can be a binary function:

```javascript
const compBin = f => g => x => y => f(g(x) (y));

compBin(sqr) (add) (2) (3); // 25
compBin(add) (add) (2) (3) (4); // 9
```
[run code](https://repl.it/@scriptum/DraftySlategrayProgramminglanguage)

`compOn = f => g => x => y => f(g(x)) (g(y))`

The main use case of `compOn` is sorting algorithms of compound values where the order is determined by another element of the compound value:

```javascript
const compOn = f => g => x => y => f(g(x)) (g(y));

const sortBy = f => xs =>
  [...xs].sort((x, y) => f(x) (y));

const compare = x => y =>
  x < y ? -1
    : x > y ? 1
    : 0;

const fst = ([x, y]) => x;

sortBy(compOn(compare) (fst))
  ([[2, "world"], [4, "!"], [1, "hello"]]); // [[1, "hello"], [2, "world"], [4, "!"]]
```
[run code](https://repl.it/@scriptum/ThankfulMoralFiles)

### Editor's note

If you enjoyed this chapter please ðŸŒŸ scriptum here on Github or share it on your preferred social media platform. If you found a mistake or inaccuracy or want to propose an improvement please file an issue/feature. Thank you.

[&lt; prev chapter](https://github.com/kongware/scriptum/blob/master/course/ch-003.md) | [TOC](https://github.com/kongware/scriptum#functional-programming-course-toc) | [next chapter &gt;](https://github.com/kongware/scriptum/blob/master/course/ch-005.md)
