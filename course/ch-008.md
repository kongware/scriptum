## From Recursion to Corecursion

**[Editor's note: this chapter is currently being edited]**

Recursion and corecursion are dual to one another. Recursion operates on data and likewise corecurtion operates on codata. While you can encode most algorithms in either of them one approach usually leads to more natural and succinct implementation. In most programming languages both approaches are not distinguished from each other on the type level and neither are data and codata. In this chapter, however, I will delineate recursion from corecursion in order to gain a deeper understanding, which is helpful to determine when to apply which approach.

### The structure of recursion

Recursion embodies the idea of recurrent function application like `f(f(...f(x)))`, where the number of applications is not known upfront. Such an function application is non-deterministic, because its number can only be determined at runtime.

An recursive algorithm consists of one ore more recursive steps and one or more base cases. A base case is the simplest, smallest instance of the problem, that cannot be decomposed any further. A recursive step decomposes a larger instance of the problem into one or more simpler or smaller instances. On the way forward to the base case either the function call stack or an accumulator is built up, which is unwind when the base case is reached. On the way back the intermediate values are recomposed to produce the solution to the original problem.

### Body and tail recursion

You can distinguish recursion by the lexical position of the recursive step within the funcion body. If it is the last operation, it is in tail otherwise in non-tail or body position. Both forms are therefore referred to as tail and non-tail or body recursion. Body recursion keeps state in the implicit function call stack, whereas tail recursion keeps it in an explicit data structure, which serves as a substitute of the call stack. This data structure is often called the accumulator.

As a consequence a body recursive algorithm builds its result from the way back from the base case, whereas a tail recursive one builds its result on the way forward from the initial case. The following examples illustrate both approaches:

```javascript
const log = x => (console.log(x), x);

// body recursive

const fibBody = n =>
  n > 1
    ? fibBody(n - 1) + fibBody(n - 2) // recursive step + implicit function call stack
    : log(n); // base case

// tail recursive

const fibTail = n => {
  const go = (x, acc, m) =>
    m > 1
      ? go(acc, acc + x, m - 1) // recursive step + explicit accumulator
      : log(acc); // base case

  return go(0, 1, n);
};

fibBody(10); // logs 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0

fibTail(10); // logs 55
```
[run code](https://repl.it/@scriptum/LimpingAromaticModule)

In the above example we log at the base case in order to reveal the internal control flow. Since the body recursive Fibonacci algorithm decomposes the problem instance to the smallest and simplest instances on the way forward to the base case, an exponentially growing number of `1` and `0` are logged. Evidently this is quite inefficient.

The tail recursive algorithm on the other hand starts its work right away from the initial case. Consequently it has already finished its work when the end is reached and only the final result is logged. Let us visualize the progress by logging the accumulator:

```javascript
const fibTail = n => {
  const go = (x, acc, m) =>
    m > 1
      ? (log(acc), go(acc, acc + x, m - 1))
      : log(acc);

  return go(0, 1, n);
};

fibTail(10); // logs 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
```
[run code](https://repl.it/@scriptum/PiercingLimitedOmnipage)

Since body recursion depends on the function call stack the problem size that can be handled is limited to the available stack size. In constrast to this tail recursion can share a single stack frame throughout the whole computation, because the accumulator takes over the role of the stack frame, provided the language persues tail call elimination. Technically tail recursion is the functional equivalent of imperative loops. Body recursion however, requires a loop along with a custom call stack structure.

Calculating the Fibonacci sequence is a problem structure that lends itself naturally to a tail recursive definition. What else distinguishes body from tail recursion? Let us use a simplified single linked list to answer this question:

```javascript
// body recursive

const foldr = f => acc => ([h, t]) =>
  h === undefined
    ? acc
    : f(h) (foldr(f) (acc) (t));

// tail recursive

const foldl = f => acc => ([h, t]) =>
  h === undefined
    ? acc
    : foldl(f) (f(acc) (h)) (t);

const sub = x => y => x - y;

const xs = [1, [2, [3, []]]];

foldr(sub) (0) (xs); // (1 - (2 - (3 - 0))) = 2
foldl(sub) (0) (xs); // (((0 - 1) - 2) - 3) = -6
```
[run code](https://repl.it/@scriptum/DimJauntyApplet)

Obviously body recursion along with single linked lists forms a right associative fold, whereas tail recursion forms a left associative one. As a matter of fact you cannot transform one into the other in a pure way without reversing the result list.

### Almost primitive recursion

Primitive (or natural) recursion is a rather limited form of recursion but entails a desirable property: It guarantees that a recursive algorithm terminates. So instead of implementing structural recursion as a whole according to its mathematical definition, I will focus on the aspect that is responsible for this property.

If we want guaranteed termination we must assure, that the recursive algorithm reaches its base case. Recursion means to decompose a problem instance to smaller or simpler ones. What we need to do is to decompose the smallest and simplest possible problem instance of a data type, because then we are guaranteed to hit the base case. For some data types the smallest, simplest instance is pretty obvious, for others it is not:

```javascript
// Array
([x]) => x;

// natural numbers
n => n - 1;
```
* primitive recursion is essentially tail recursion accumulator style

```javascript
const _let = f => f();

const natPow = x => n => {
  const go = (m, r) =>
    m <= 0
      ? r
      : go(m - 1, x * r);

  return go(n, 1)
};

const natPow_ = x => function go(n) {
  return n <= 0
    ? 1
    : x * go(n - 1);
};

const natFact = n => {
  const go = (m, [x, y]) =>
    m <= 0
      ? y
      : go(m - 1, [x + 1, (x + 1) * y]);

  return go(n, [0, 1]);
};

const comp = f => g => x => f(g(x));
const snd = ([_, y]) => y;
const fst = ([x, _]) => x;

const natFact_ = comp(snd)
  (function go(n) {
    return n <= 0
      ? [0, 1]
      : _let(([x, y] = go(n - 1)) =>
          [x + 1, (x + 1) * y])});

const natFib = n => {
  const go = (m, [x, y]) =>
    m <= 0
      ? x
      : go(m - 1, [y, x + y]);

  return go(n, [0, 1]);
};

const natFib_ = comp(fst)
  (function go(n) {
    return n <= 0
      ? [0, 1]
      : _let(([x, y] = go(n - 1)) =>
          [y, x + y])});

natPow(2) (8); // 256
natFact(5); // 120
natFib(10); // 55
```
[run code](https://repl.it/@scriptum/BetterGoldenCommunication)

***

If every recursive step shrinks the problem, and the base case lies at the bottom, then the recursion is guaranteed to be finite. With the previous approaches it is up to the developer to ensure that and thus to avoid infinite recursion. With natural recursion (a.k.a. structural or primitive recursion) we can free us from this obligation. It forms recursive algorithms that consume data in a way which stops.

In the previous section I stated that the Fibonacci sequence is a naturally recursive problem. It indeed is but we can still define the underlying natural numbers as a recursive type (pseudo code):

`Nat = Zero | Succ(Nat)`

This reads as follows: A natural number `Nat` can either be defined as `Zero` or as the successor of another natural number. If we replace `Zero` with `0` and `Succ(Nat)` with `1+` the underlying idea is pretty obvious. Using this type definition the natural number `3` is encoded as `Succ(Succ(Succ(Zero)))`.

This is the first time I talk about types, so let us clarify the jargon. `Nat` itself is a type whereas `Zero` and `Succ` are value constructors. While `Zero` is a nullary value constructor, because it does not take any type arguments, `Succ` is an unary constructor expecting a single type argument. A type can comprise one or several value constructors.

Value constructors represent the introduction rules of a type. Consequently we can define the elimination rule by inversing this procedure:

```javascript
const foldNat = zero => succ => n => {
  const go = m =>
    m <= 0
      ? zero
      : succ(go(m - 1));

  return go(n)
};

const comp = f => g => x => f(g(x));
const fst = ([x, y]) => x;

const fib = comp(fst)
  (foldNat([0, 1])
    (([x, y]) => [y, x + y]));

fib(10); // 55
```
[run code](https://repl.it/@scriptum/HelplessAptLivecd)

`foldNat` is the elimination rule of the natural number type. It inverses the introduction procedure by reducing the current state by one until the base case `0` is reached.  Provided you pass a total successor function to `foldNat`, the recursion is guaranteed to terminate. By the way, it is not a coincidence that each value constructor of the natural number type reappears as a formal parameter of the fold. An elimination rule must always comprise all value constructors to be complete and valid.

Here is another example for the single linked list type (pseudo code again):

`List a = NIL | Cons(a, List a)`

Before we move on to the implementation let us have a look on the given type definition, because it differs from the previous one in two aspects. First `List a` is not just a type but a type constructor, because it requires a type argument to become a complete type. It is a composite type so to speak. Secondly `Cons` takes two type arguments and is thus a binary value constructor.

```javascript
const foldList = nil => cons => xs => {
  const go = ([head, tail]) =>
    head === undefined
      ? nil
      : cons(head) (go(tail));

  return go(xs);
}

const Nil = []
const Cons = x => xs => ([x, xs]);

const sub = x => y => x - y;

const xs = Cons(1) (Cons(2) (Cons(3) (Nil)));

foldList(0) (sub) (xs); // 2
```
[run code](https://repl.it/@scriptum/AssuredIdealisticOffice)

Defining the elimination rule for the list type is based on the same rules as for natural numbers. It is a rather mechanical process. Almost every recursive problem or data structure can be expressed with a naturally recursive algorithm.

### Tail call and CPS transformation

Tail recursive algorithms are more efficient than body recursive ones and are sufficient for many recursive tasks. But what are the rules to transform a body recursive function into a tail recursive one and which elements are involved? Let us go through an example step by step:

```javascript
const factBody = n =>
  n === 0
    ? 1 // base case + neutral element
    : factBody(n - 1) * n; // recursive step + implicit function call stack
```
First we must identify the portion of this body recursive code that is evaluated after the recursive step: `[...] * n`. Please note that I denoted the hole in the expression with `[...]`. Next we take this expression and use it as the second argument of the recursive function. The hole is replaced with another argument, which accumulates the result: `factBody(n - 1, acc * n)`.

In order to hide the internal API we use an inner auxiliary function `go` so that `factBody` still only requires a number as an argument: `go(n - 1, acc * n)`. Usually I only use curried functions but since `go` is not visible in the pasrent scope and recursion often has a heavy workload a multi argument function is used for performance reasons.

As a last step we replace the neutral element of the base case with the accumulator `acc`, because when the base case is reached, a tail recursive algorithm has already finished its work and can just return the accumulated result:

```javascript
const factTail = n => {
  const go = (acc, m) =>
    m === 0
      ? acc // base case
      : go(m * acc, m - 1); // recursive step + explicit accumulator

    return go(1, n); // neutral element
};
```
As you can see the implicit function call stack is substituted by an explicit accumulator. The neutral element is passed as an argument of the initial call. It is thus no longer used within the last iteration of the recursive algorithm but in the first one.

We could just stop at this point since we have successfully completed the tail call transformation. However, there is an even more powerful encoding which we can transform into, so let us keep transforming. What happens if we defer the multiplication `m * acc` by putting it into a lambda, which itself is passed as the last argument of `go`: `go(m - 1) (acc => m * acc)`.

Now we have a bunch of disconnected function arguments, one for each iteration. In order to connect them with each other we have to apply each result of the multiplication to the previous function argument: `go(m - 1) (acc => k(m * acc))`. Here is the big picture:

```javascript
const factCont = n => {
  const go = m => k =>
    m === 0
      ? k(1) // base case + neutral element
      : go(m - 1) (acc => k(m * acc)); // recursive step + explicit accumulator

    return go(n) (x => x); 
};

factCont(5); // 120
```
[run code](https://repl.it/@scriptum/FlatFloweryDifferences)

Do you see the pattern? Each function invocation ends with a continuation, i.e. a function argument, which is finally called within the function body. This pattern is called continuation passing style and will be covered in deatil in a later chapter.

We have succeeded in writing three different recursive algorithms for the factorial numbers. Let us examine if the CPS version creates a computational structure that is body or tail recursive. A viable approach to do so is to visualize the nested expression each algorithm builds:

```javascript
const factBody = n =>
  n === 0
    ? 1 // base case + neutral element
    : `(${factBody(n - 1)} * ${n})`; // recursive step

const factTail = n => {
  const go = (acc, m) =>
    m === 0
      ? acc // base case
      : go((`(${m} * ${acc})`), m - 1); // recursive case

    return go(1, n); // neutral element
};

const factCont = n => {
  const go = m => k =>
    m === 0
      ? k(1) // base case + neutral element
      : go(m - 1) (acc => k(`(${acc} * ${m})`)); // recursive case

    return go(n) (x => x); 
};

factBody(5); // (((((1 * 1) * 2) * 3) * 4) * 5)
factTail(5); // (1 * (2 * (3 * (4 * (5 * 1)))))
factCont(5); // (((((1 * 1) * 2) * 3) * 4) * 5)
```
[run code](https://repl.it/@scriptum/EarnestUnripeRuntimeenvironment)

The CPS version pursues the same computation strategy as the body recursive approach. Since with CPS all continuation invocations are in tail position we can have both, efficient tail calls and a body recursive computation strategy. This is a big win!

### Indirect or mutual recursion

If function `foo` calls function `bar`, which calls function `bat`, which in turn calls `foo` again then all three involved functions are recursive, indirectly recursive to be precise. The following example is not very efficient and a bit contrived but serves the purpose to illustrate the mechanism:

```javascript
const fibChild = n =>
  n < 1
    ? 1
    : fib(n - 1);

const fib = n =>
  n < 1
    ? 0
    : fib(n - 1) + fibChild(n - 1);

fib(10); // 55
```
[run code](https://repl.it/@scriptum/FlippantRedundantVisitor)

Indirect recursion allows very elegant algorithms when working with tree data structures. We will look into such algorithms in the corresponding chapter of this course.

### Anonymous recursion

The `fix` combinator allows anonymous recursion by supplying the deferred recursive step as a function argument:

```javascript
const fix = f => x => f(fix(f)) (x);

const fib = fix(go => n =>
  n > 1
    ? go(n - 1) + go(n - 2)
    : n);

fib(10); // 55
```
[run code](https://repl.it/@scriptum/SlategrayWiryBoolean)

While having an elegant API `fix` is not tail recursive and hence not stack safe. In the following sections we are going to see that trampolines are the better alternative for almost all cases.

### Corecursion and codata

In most functional languages there is no distinction between recursion on data on the one hand and corecursion on codata on the other hand. I am going to make this distinction anyway, because I think it helps to get a better intuition of both concepts.

Corecursion is dual to recursion. While recursion means to call oneself on smaller data chunks at each iteration until the smallest possible data chunk is reached, corecursion means to call oneself on data at each iteration that is greater than or equal to what one had before. Recursion does the actual work on the way back from the base case. Corecursion already does the work on the way forward and thus creates intermediate values rigth away, before the entire data structure is traversed. Consequently corecursion can 

Reducing data must inevitably end at some point as soon as the smallest possible data is reached. You can think of recursion as an algorithm that consumes finite data in a way that stops. Expanding data on the other hand is an infinite process, hence you can think of corecursion as an algorithm that consumes infinite data in a way that continues:

```javascript
const snoc = x => xs => (xs.push(x), xs);

const Nil = null;
const Cons = head => tail => ({head, get tail() {return tail()}});

const fibs = Cons(0) (() => Cons(1) (() => {
  const go = (xs, ys) =>
    Cons(xs.head + ys.head) (() => go(xs.tail, ys.tail));

  return go(fibs, fibs.tail);
}));

const take = n => xs => {
  const go = (acc, {head, tail}) =>
    head === undefined || acc.length === n
      ? acc
      : go(snoc(head) (acc), tail);

  return go([], xs);
};

take(10) (fibs); //Â [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```
[run code](https://repl.it/@scriptum/SvelteHotpinkCarrier)

Maybe you have noticed that corecursion is a lot like tail recursion. Just as with tail recursion corecursion uses an accumulator but it isn't passed as an explicit argument but implicit by expanding the value constructor or array literal in the example above.

Besides corecursion is based on lazy evaluation. It does not iterate in tail position but within a value constructor, so it requires lazyness to avoid infinite recursion. As a result a corecursive algorithm acts like a pull stream: No values are produced unless the evaluation is enforced by another function, which consumes the value stream up to a certain point.

### Recursion as a last resort

As I have already mentioned at the beginning of this chapter recursion und corecursion are functional primitives. Functional programmers usually prefer I higher level of abstraxction to work with. Abstractions are a mixed blessing though: On the one hand they spare us a lot of details and reduce the mental load. But on the other hand you have to be familiar with these abstractions and be trained how to handle them effectively. Let us illustrate the issue by taking another look at the corecursive `fibs` function:

```javascript
const fibs = Cons(0) (() => Cons(1) (() => {
  const go = (xs, ys) =>
    Cons(xs.head + ys.head) (() => go(xs.tail, ys.tail));

  return go(fibs, fibs.tail);
}));
```
We can greatly simplify it by using a fold abstraction:

```javascript
const fibs = unfoldr(
  ([x, y]) => Some([x, [y, x + y]])) ([0, 1]);
```
Of course you can only comprehend this abstraction if you are familiar with `unfoldr` and unfolding in general. And applying it yourself takes even more experience. However, when you are an experienced functional programmer you will highly appreciate a certain level of abstraction, because it spares you a lot of distracting details and unnecessary boilerplate.

Bottom line recursion and corecursion are a last resort that we sometimes need when we have to deal with a very specific problem or rely on micro optimizations for a performance critical portion of our code. Otherwise we try to avoid the low level work and appreciate the blessing of higher abstractions.

### Editor's note

If you enjoyed this chapter please ðŸŒŸ scriptum here on Github or share it on your preferred social media platform. If you found a mistake or inaccuracy or want to propose an improvement please file an issue/feature. Thank you.

[&lt; prev chapter](https://github.com/kongware/scriptum/blob/master/course/ch-007.md) | [TOC](https://github.com/kongware/scriptum#functional-programming-course-toc) | [next chapter &gt;](https://github.com/kongware/scriptum/blob/master/course/ch-009.md)
