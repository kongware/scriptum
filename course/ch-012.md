## A Little Type Theory

**[Editor's note: this chapter is under edit]**

Functional progamming is type directed programming, hence we need to acquire some type theoretical background, even though the first part of this course relies on untyped code. If we introduce types we must distinguish the type from the term (or value) level. The type level can be quite confusing but luckily both type and term level are similar to each other, because each concept at the type level has a correspondance at the term level. Please note that I will use Typescript notation to annotate types.

### Structural versus nominal type system

There are two major classes of type systems: Nominal and structural ones. A nominal type systems determines type equivalence by considering only the names of types. A structural type system determines type equivalence by considering only the structure of types:

```javascript
type foo = {x: number};
type bar = {x: number};
```
In the example above `foo` and `bar` are nominally non-equivalent but structurally equivalent, that is, with nominal typing values of `foo` and `bar` are of different type, whereas with structural typing they are of the same type.

Please note that most type systems are a blend of nominal and structural typing.

### Monomorphic types

A monomorphic type or in short a type is like a constant at the term level. It is complete and can no longer be modified:

```javascript
undefined // undefined

null // null

123 // number

[1, 2, 3] // number[]

new Set(["foo"]) // Set<string>

{foo: [1, 2, 3]} // {foo: number[]}

const map = f => xs => xs.map(f);
const len = xs => xs.length;

map(len) (["f", "fo", "foo"]) // <string, number>(f: (x: string) => number) => (xs: string[]) => number[]
```
A type can be inhabited by either no value at all (`undefined`), one value (`null`) or any number of values (`number`). Please note that I pretend that `undefined` would be no value, because it denotes a type error and should terminate the program immediately.

I left out the type for `map` and `len`, because their types are not monomorphic but polymorphic.

### Polymorphic types

The motivation for polymorphism in type systems comes from the idea of generalization: We always strive to apply a concept to a wider range of scenarios. In terms of a type system this means different data structures and expressions can have the same type.

#### First-order type constructors

A first order type constructor or in short type constructor also known as parameterized type is like a function at the term level. A type constructor takes one or more types and returns a new type. Let us examine the two polymorphic types of the last example:

```javascript
const map = f => xs => xs.map(f); // <A, B>(f: (_: A) => B) => (xs: A[]) => B[]
const len = xs => xs.length; // <A>(xs: A[]) => number

len("foo"); // number
map(len) (["f", "fo", "foo"]) // <string, number>(f: (x: string) => number) => (xs: string[]) => number[]
```
`len` takes a single type `A` and returns a `number`. `A` is a type variable that serves as a placeholder for a type yet to be provided. If we pass a `string` to `len` it yields `number`. `map` is a binary type constructor, because it expects two types `A` and `B` before it is able to produce a new type. If we pass `len` and `string[]` it yields `number[]`. So whenever you stumble upon a polymorphic or parameterized type, simply think of it as an ordinary function that takes and returns types instead of values.

#### Higher-order type constructors

Just like higher-order functions can take other functions as arguments at the term level, higher-order type constructors can take other type constructors as arguments at the type level. This is possible, because both functions and type constructors are first class. In type theory parlance this is also referred to as higher-kinded types. We will learn about the kind system in a later section of this chapter.

Let us take the arry type constructor `A[]` and transform it into higher-order one. First we pick the more verbose form `Array<A>`. Then we abstract from the type constructor itself (`Array`) by replacing it with another type variable: `T<A>`. This is a type that takes a first class type constructor function `T` and a type `A` to produce a new type. Please note that I use a hypothetical Typescript notation, because its type system does not support higher-order type constructors. Just like a higher-order function is more general than a first-order oone a higher-order type constructor can produce a wider variety of types than its first-order counterpart.

Please note that there is a workaround available in the Typescript community to mimic higher-order type constructors. However, I consider it to be too complex to be demonstrated in this chapter.

#### Higher-rank type constructors

Our new gained ability to pass first class type constructors to higher-order type ones is somewhat limited:

```
type foo = <A, B>(f: (_: A) => string) => (x: A) => (y: B) => string;
const foo:foo = f => x => y => f(x) + f(y); // type  error
//                                      ^
```
Only `foo`'s caller can decide which type to pick for `f`, i.e. we cannot pass polymorphic type constructors around, only monomorphic ones. Higher-rank type constructors enable first class polymorphic type constructors by introducing scopes for type variables on the left-hand side of the `=>` operator. This kind of polymorphism is a bit harder to grasp, because it has no equivalent at the term level. Typescript does not support higher-rank polymorphic types but in the following example I use curyl braces as an hypothetical annotation extension to illustrate the idea:

```
type foo = <A, B>(f: {(_: A) => string)} => (x: A) => (y: B) => string;
const foo:foo = f => x => y => f(x) + f(y); // type checks
```
Now `(_: A) => string` has its own scope and is not affetced by the type the outer `A` is assigned to when `x` is passed.

#### Parametric polymorphism also known as generics

A parametric polymorphic function acts uniformly on all types. As a result it must not know anything about its polymorphic arguments, because they can be of any type - a property which is referred to as parametricity. While this strict form of polymorphism allows the definition of very generic functions, it considerably narrwos down the possibilities of what you can do with these polymorphic arguments.

There is only a single first-order function, which is fully parametric polymorphic in its arguments: The identity function `id = <A>(x: A): A => x`, which simply puts a value into a function context. Parametric polymorphism is much more useful in connection with higher-order functions:

```javascript
type arrMap = <A, B>(f: (x: A) => B) => (xs: A[]) => B[]
const arrMap: arrMap = f => xs => xs.map(f);
```
`arrMap` is parametric polymorphic in `A` and `B`.

#### Ad-hoc polymorphism also known as name overloading
***

Name overloading simply means a mapping from a single name to several types. The mapping is either resolved at compile or at runtime. Here is a simple example with a first-order function:

In Typescript we can declare overloaded functions and methods:

```javascript
function eq(x: string, y: string): boolean;
function eq(x: number, y: number): boolean;
function eq(x: boolean, y: boolean): boolean;

function eq(x: any, y: any) { return x === y };

// well typed

eq(123, 123);
eq("foo", "foo");
eq(true, false);

eq(123, "foo"); // type error
```
[run code](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAUwI4AoAeAuRBnKAJxjAHMAaRAT1wOLIEpcAjOOAG2QEMwBuAWABQoSLAQoMORGBABbZskKUa0uQsJNErDtz5CR0eEjRYWbTj2VmdPTdot7B+8IfEmpPKlcSeGiAN6IhMhQIIRImIgAvDHUiAC+Ak6CJgCMAEwAzJQZmQxJJgBEwGyFlMWl+UImRCDIlMBc7HjIVSkYueUlcIX5QA)

Name overloading becomes more useful in connection with higher-order functions:

```javascript
function eq(x: boolean, y: boolean): boolean;
function eq(x: number, y: number): boolean;
function eq(x: string, y: string): boolean;

function eq(x: any, y: any) { return x === y } typeof eq;

const arrEq = <A>(eq: (x: A, y: A) => boolean) => (xs: A[]) => (ys: A[]) => {
    const go = (b: boolean, i: number): boolean =>
        b === false ? false
            : i === xs.length ? true
                : go(eq(xs[i], ys[i]), i + 1);

    return xs.length !== ys.length
        ? false
        : go(true, 0);
};

arrEq(eq as (x: number, y: number) => boolean) ([1, 2, 3]) ([1, 2, 3]);
arrEq(eq as (x: number, y: number) => boolean) ([1, 2, 3]) (["foo", "bar", "baz"]);
```
[run code](https://www.typescriptlang.org/play/?ssl=1&ssc=1&pln=19&pc=84#code/GYVwdgxgLglg9mABAUwI4AoAeAuRAjOOAG2QEMwAaRAT1wOLLAEo7CTyBuAWAChRJYCFBhyIwIALZ5kAJyq0xk6TJb42jbn3DR4SNFlwBnKDJhgA5vKMmz51fXZhNvfjqH7R5alcRemiAG9EGWQoEBkkTEQAXliaRABfRChqAAdkOGBhZx4IBGNfGRkAUVQYxAAeAEEAPnQ0XANEKp8q-2iatQZyds6sQ1wqgG0AXV7EdGoB5tHxgN5ERcQ8sALzOHL0PFZuykQYXHEpWXt1chiahaXrvBi44FIiQ2REAH5EB6fkK+vfxFwYHdoohMIYAHQkCxQAAWb2SMhA3x4fxRS1w63qIkMQxgI3k2NxTCogIA1IgAIxMHLXEJhCIg8GQ8wwxAAQjiUwhyCh0J+v3en2efOu6Lg6BMiKoAAYqbwEjlSEVSpjfIYJqIjsofJqThcuo5-OghuSqAAmKgAZjGE2NZstY00ipKGDQqvVhyUsm1npUeocjENtsQ5sQVsDACJgIRw1Rw3hFTHEHHSAAvcMOoA)

Here we have a generic `arrEq` function that has a constraint on its polymorphic type parameter, i.e. we have made the function less polymorphic but more expressive.

Please note that we need a type holes because of Typescripts limited type inference capability.

Compared to the previous example it works the other way around. We start with a parametric polymorphic higher order function and pass it an overloaded function `arrEq(eq)`, which renders the type variable `A` less polymorphic, namely ad-hoc polymorphic. You can think of such a partially applied function as one with a constraint on its type variable: The function still must not know anything about the proper type its type variable will be applied to except for the aspect implemented by the type class. Consequently such a function can only be invoked with types that have an instance of this very type class and its overloaded names - `eq` in the example above.

Type classes go beyond simple name overloading by giving the mapping from one name to many types itself a name. Now we can refer to this mapping or assign several overloaded names to it, that is, we can put overloaded names into a relation. A type that has an instance of such a type class must respect this relation and implement all overloaded names. Additionally we can express specific laws the overloaded functions of the type class must abide by. Or we can form type class hierarchies, where a subclass inherits overloaded names from a superclass.

In this course we will use a technique called dictionary passing style, because Typescript only supports runtime name overloading - the most primitive form of ad-hoc polymorphism. While dictionary passing style is as expressive as type classes it comes at the price of making your code more verbose. They act like explicit type classes.

#### Subtype polymorphism also known as subtyping

Subtyping defines a subtype-supertype relationship between two types. This form of polymorphism is widely used in object-oriented programming. Various multi-paradigm languages with strong roots in functional programming incorporate different forms of subtype polymorphism in their type systems. However, in this course we will not engage any further with this topic.

#### Row polymorphism

Row polymorphism enables record types to be polymorphic in their fields. Such a type accepts records with more fields than it has declared itself, provided these extra fields coincide for all involved records:

```javascript
type foo = { first: string, last: string };

const o = { first: "Foo", last: "Oof", age: 30 };
const p = { first: "Bar", last: "Rab", age: 45 };
const q = { first: "Baz", last: "Zab", gender: "m" };

const foo = <T extends foo>(o: T) => (p: T) =>
  `${o.first} ${o.last}`;

foo(o) (p); // type checks
foo(o) (q); // type error
```
The type variable `T` gathers all extra fields of the record type which are not part of the expected type. It is called a row variable. In order to type check all involved records including their row variables must have the same type. Downcasting a record type to one with fewer fields usually leads to information loss. With row polymorphism this can be avoided, since the full type information is maintained within the row variable.

### Value constructors

A value constructor takes no, one or more values and returns a new value. It exists at the term level of the language. In Javascript there is no difference between a value constructor and a normal function. However, in other more advanced functional languages there is one. A value constructor that takes no argument is just a typed constant like `true`/`false`.

`null` is both a nullary type constructor (or just a proper type) and a nullary value constructor (or a typed constant). The type is only inhabited by a single value. `boolean` is also a proper type but inhabited by two values, namely the typed constants `true`/`false`.

`A[]` is a type constructor, because it needs a type (e.g. `string`) to create a proper type (`string[]`). `Array` is a value constructor, because it needs a value (e.g. `"foo"`) to create a new value (`["foo"]`).

In Javascript the only way to create custom types is to declare a new `Object` type, either by using object factories like `Foo` from the example above or by subclassing (see `NonEmpty`).

If a value constructor takes more than a single value, the associated type forms a product type:

```javascript
type Pair = <A, B>(x: A, y: B) => [A, B]; // type constructor
const Pair: Pair = (x, y) => [x, y]; // value constructor
```
 If a type constructor is associated with more than one value constructor, the underlying type forms a sum type:
 
```javascript
const True = {tag: "True"} as const
const False = {tag: "False"} as const;

type Bool = typeof True | typeof False; // two value constructors
```
A tagged union is an alternate way to declare booleans. Unfortunately Typescript is quite verbose regarding the declaration of tagged unions. Here is the succinct Haskell counterpart: `data Bool = False | True`.

Here is another data declaration of a tagged union. Functional linked `List`s comprise an unary type constructor as well as a nullary and an unary value constructor. Besides they have a recursive type definition, because `List<A>` occurs in the body of the `Cons` value constructor:

```javascript
const Nil = {tag: "Nil"} as const
const Cons = <A>(head: A) => (tail: List<A>) => ({tag: "Cons", head, tail} as const);

type List<A> = typeof Nil | typeof Cons;
```
### Kinds - the type of types

TODO

### Editor's note

If you enjoyed this chapter please ðŸŒŸ scriptum here on Github or share it on your preferred social media platform. If you found a mistake or inaccuracy or want to propose an improvement please file an issue/feature. Thank you.

[&lt; prev chapter](https://github.com/kongware/scriptum/blob/master/course/ch-011.md) | [TOC](https://github.com/kongware/scriptum#functional-programming-course-toc) | [next chapter &gt;](https://github.com/kongware/scriptum/blob/master/course/ch-013.md)
