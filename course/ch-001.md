## Functional Jargon and Programming Experience

This first chapter introduces important functional programming jargon and gives you a preview of the functional programming experience.

### First class values

Values are expressions that cannot be evaluated any further. Technically speaking they are expressions in normal form (NF). In Javascript we can represent values of most data types in literal form:

```javascript
"foo"
123
true
[1, 2, 3]
{foo: "bar"}
a => a
/^[A-Z]$/
```
You can pass values to and return them from functions. This trait is referred to as first class. Values are first class entities.

### First class expressions

Values are the most fundamental entity of programming but not particularly useful on their own. Fortunately we can generalize them to expressions. Generally speaking (pun intended) the process of generalization means to make things more useful, i.e. applicable to a wide range of scenarios.

```javascript
"foo" + "bar"
123 â€“ 1
true && false
[1, 2, 3] [0]
({foo: "bar"}).foo
(a => a) ("foo")
```
Expressions are also first class. However, in Javascript there is no difference between them and values in this regard, since expressions are always evaluated before they are passed to or returned from a function. Other languages pursue different evaluation strategies. Functional languages sometimes have a call-by-need strategy, in which an expression is only evaluated when it is actually needed. Expressions are a great improvement compared to mere values. But we can only use them ad-hoc, that is in place and as is. Is there a way to make them less ad-hoc? Let us generalize further!

### First class functions

Imagine named expressions with holes in them and a mechanism to fill these holes when needed. Such generalized expressions would be way more flexible, because their results vary by means of the provided values. I am obviously talking about functions. Since functions are just expressions with holes in them they are also first class entities.

```javascript
const foo = hole => `expression with a ${hole} in it`;
foo("bar") // expression
```
We can call `foo` once, twice, several times or not at all. It is only evaluated when needed. This is similar to the call-by-need evaluation strategy I mentioned above. Functions are lazy evaluated by design.

The ability to reuse functions allows us to compose them, provided the involved types match. Using composition we can create more complex functions out of simpler ones, which further increase their reusability.

```javascript
add(length("foo")) (length("bar"))
```
When functions are just first class expressions with holes in them, what differentiates them from, say, literals or other expressions? Nothing really, except that they are more general. This is exactly how we regard functions in functional programming: they are just ordinary values and we treat them accordingly.

I use the hole metaphor, because it helps understanding the _is-a_ relation between functions and data. In the functional paradigm functions are understood rigurously mathematic, though. They are mere mappings from input to output.

### Pure functions

Admittedly, I oversimplified a bit. In fact three restrictions are necessary in order for functions to be able to act like ordinary values:

* they must return a result value no matter what arguments are provided
* they must return the same result value for the same arguments
* they must not perform another visible effect than creating and returning a result value

The first restriction forms total functions and we are going to discuss them in the next paragraph. The latter two constitute pure functions. A pure function must be deterministic and must not perform visible side effects so that you can substitute its invocations with the respective result values without changing the behavior of the program. In the literature this restriction is called referential transparency. Only such pure functions can be regarded as ordinary values.

These two related questions frequently come up on the topic:

* if a function declaration includes impure expressions but the effect(s) are not visible outside the function scope, calling it can be still considered a pure expression
* if an otherwise pure function depends on an impure one it is also impure, because impurity is infectious

### Idempotent functions

Functions for which applies `f(f(x)) === f(x)` are referred to as idempotent ones. Idempotence is a desirable property, because it allows an at-least-once semantics as opposed to exactly once. Idempotence is orthogonal to purity, i.e. an idempotent function must not be pure and vice versa:

```javascript
const toUC = s => s.toUpperCase(),
  inc = x => x + 1,
  delFoo = o => (delete o["foo"], o),
  log = x => (console.log(x), x),
  o = {foo: 123, bar: "abc"};
  
// idempotent pure function
toUC(toUC("hey")) === toUC("hey"); // true

// non-idempotent pure function
inc(inc(0)) === inc(0); // false

// idempotent impure function
delFoo(delFoo(o)).toString() === delFoo(o).toString(); // true

// non-idempotent impure function
log(log("foo")); // logs twice
log("foo"); // logs once
```
As you can see even an impure function can be idempotent in its side effect.

### Total and partial functions

The functional paradigm considers functions as mappings from domain (arguments) to codomain (result values). If every argument (or set of arguments) yields a result value we are talking about total functions. Otherwise it is a partial one:

```javascript
const head = xs => xs[0];
head([1, 2, 3]); // 1
head([]); // undefined
```
`head` is a partial function because it returns undefined in certain cases, which indicates a type error. You should either avoid such functions or throw an error explicitly instead of silently returning `undefined`. Partial functions are per se less predictable and reliable than total functions.

You can transform any partial function into a total one by using the `Option` type. `Option` is one of the most common functional types. It will be covered in a later chapter.

### Higher order functions

We are not done generalizing. If functions are just first class values let us pass a function to another one and see what is happening:

```javascript
const app = f => x => f(x);
const add = x => y => x + y;
const sub = x => y => x â€“ y;

app(add) (2) (3) // 5
app(sub) (2) (3) // -1
```
What we are doing here is a kind of dependency injection. Such functions are called higher order functions, because they expect at least one function argument. Consequently functions without a function argument are called first order functions.

Please note that a function without function arguments that returns another function is not a higher order function but a curried one. We will deal with currying in a later chapter of this course.

You can most likely imagine how powerful higher order functions are, since they are so generalized. As I have already mentioned the process of generalization means to make things more useful.

### Are statements harmful?

No, but they are like dead ends in your code, because they are decoupled from one another. Since they do not evaluate to a value you need to bind their (intermediate) results to names explicitly in order to use them in other statements. As a result you have to declare a lot of name bindings to store all these accruing intermediate values:

```javascript
const x = 1 + 2;
const y = 2 + 3;
const z = x * y;
```
I use the term name binding instead of variable, because there is no such thing as a variable in functional programming. All we can do is bind immutable values to names. Name bindings themselves are also immutable, i.e. you cannot reassign them. In Javascript, however, this is just a policy we need to adhere to.

Later in this course you will see that statements obstruct the functional control flow, which consists of various forms of function composition.

### Are operators special?

In functional programming operators are just functions in infix position (e.g. `x + y`), which have a predefined precedence and associativity. Functions on the other hand are usually written in prefix notation (e.g. `add(x) (y)`) and their application is left-associative and has a higher precedence then every other operator.

Some functional programming languages allow partially applying operators, which is referred to as left and right sectioning. Others even allow declaring custom operators with their own precedence and associativity. As you can see there should be nothing special about operators. Unfortunately in Javascript operators are special and are not first class. So we have to imitate their behavior with functions.

### Evaluation strategies

**[Editor's note: this section needs edit]**

Lambda Calculus, the theoretical foundation of functional programming, does not enforce a particular evaluation order but leaves it to the language to pick a strategy.

It does not stipulate a certain evaluation strategy but leaves it to the individual language/compiler to pick one. Let me illustrate this with using the `if`/`then`/`else` construct in Haskell. As opposed to Javascript it is an expression, i.e. it always must return a value. For that reason you always must provide an `else` strand. The usual evaluation order of `if expa then expb or expc` would be either `expa`/`expb` or `expa`/`expc` depending on `expa`. But a language/compiler could also chose a more esoteric strategy as first evaluating `expb`/`expc` and only then `expa`. If `expb`/`expc` yields the same result in this scenario, the evaluation of `expa` could be dropped entirely.

Can we therefore claim the functional programming has no evaluation order and thus no control flow in the sense of imperative programming? I think this is too much a simplification:

```javascript
// function application

f(g(x))
(f g) x // replacing parenthesis to reveal associativity

// function composition

comp(comp(comp(f) (g)) (h)) (i)
comp (comp comp) // dropping arguments and replacing parenthesis to reveal associativity
```
Function application is left associative, whereas function composition is right associative. For this reason both constructs enforce an evaluation order. Another example:

```javascript
readUserInput()
logUserInput()
```
The program above requires an evaluation order to be sensible. We can compose both expressions by hand or use an appropriate instance of the famous monad type class to ensure it.

While there is no specific evaluation strategy in general there are a couple of aspects that have an impact on evaluation order. Operator presedence, operator associativity and lazy evaluation are the most important ones.

### The functional programming experience

#### Composition

Composition lets us break down large problems into many smaller ones, which are addressed by pure, small functions and then recompose these functions to solve the original problem. This approach has far-reaching consequences on the coding style. Since such functions tend to be focused on a single concern, we gain a high degree of code reuse. Since such functions are pure we can easily test them without mocking the real world. If you recompose small functions with meaningful names you get back pretty descriptive code which abstracts from the underlying algorithm.

#### Local and equational reasoning

We have already learned that functional programming is based on referential transparency. But this is only a technical term. How do we benefit from this property? Well, it enables local reasoning and this is a pretty amazing quality. Local reasoning means we can think about an expression which sticks deep inside the structure and logic of our program without having to be concerned about this very context. With the absence of side effects we can focus on the piece of code we are interested in no matter how extensive the program becomes. Local reasoning is complemented by equational reasoning, which describes thinking about code using algebraic laws, which result in principled code changes that work as predicted. Some of these laws you know from school, so there is nothing scary about them:
```
(a + b) + c = a + (b + c) // associative law
a + b = b + a // commutative law
a * (b + c) = a * b + a * c // distributive law
```
#### Effects as values

Functional programming can be essentially described as programming with values. We have already learned that functions are values. In the same sense effects are values, because
computations in an effectful context are put into sealed boxes or container types, where their execution is deferred and from which their results cannot be freely retrieved. This way the effect is ultimately tied to a value of a certain type and we can pass around this value as any other first class citizen.

#### Recurring general patterns

Functional patterns tend to be so general that they are applicable in a wide range of contexts. You will stumble upon such patterns throughout functional code bases, which is very helpful in understanding the intention of code and becoming more familiar with it. This often also applies cross language, because despite the syntactic differences functional patterns are mainly shaped by math not by particular languages.

#### The functional paradox

For novices as well as professionals functional programming is harder up front but gets easer during the process, because the paradigm forces you to not make shortcuts for future benefit. This applies for both the learning curve in general and individual problems. Sticking to all these rules might be annoying in the short term but it will save you a lot of trouble in the long run.

### Editor's note

If you enjoyed this chapter please ðŸŒŸ scriptum here on Github or share it on your preferred social media platform. If you found a mistake or inaccuracy or want to propose an improvement please file an issue/feature. Thank you.

[TOC](https://github.com/kongware/scriptum#functional-programming-course-toc) | [next chapter &gt;](https://github.com/kongware/scriptum/blob/master/course/ch-002.md)
